Этот этап — один из самых захватывающих. Мы переходим от теории к **Layout** (компоновке) реального интерфейса. Автор ставит перед тобой классическую задачу: как расположить элементы вертикально один за другим?

Давай разберем это «под капотом» так, как это видит опытный разработчик.

---

### 1. Как Flutter понимает "один под другим"?

Автор описывает структуру: Текст -> Поле ввода -> Кнопка. Во Flutter для этого существует специальный виджет — **Column** (Колонка).

**Что происходит под капотом:**
Виджет `Column` — это виджет с несколькими детьми (`children`). В отличие от `Center`, который работает только с одним ребенком, `Column` берет список виджетов и распределяет их в вертикальном пространстве.

---

### 2. Главная и Поперечная оси (Axis)

Чтобы профессионально управлять `Column`, тебе нужно понять концепцию осей. Это база для любого Flex-дизайна (как в вебе Flexbox):

- **Main Axis (Главная ось):** Для колонки это вертикаль (сверху вниз).
- **Cross Axis (Поперечная ось):** Для колонки это горизонталь (слева направо).

**Почему это важно:**
Когда автор говорит «три элемента ниже друг друга», Flutter должен решить: прижать их к верху, растянуть по центру или растолкать по краям? За это отвечают свойства `mainAxisAlignment` и `crossAxisAlignment`. По умолчанию `Column` прижимает всё к самому верху и центрирует по горизонтали (если не указано иное).

---

### 3. "Жадность" виджета Column

Это то, на чем ловятся многие новички.

- **По вертикали (Main Axis):** `Column` ведет себя «жадно». Она пытается занять **всю доступную высоту** (от верха до низа экрана).
- **По горизонтали (Cross Axis):** Она ведет себя «скромно». Она подстраивается под ширину самого широкого своего ребенка.

**Профессиональный совет:** Если ты положишь `Column` внутрь `Center`, она центрирует группу элементов по горизонтали, но сама группа все равно будет растянута от верха до низа. Чтобы сжать колонку под размер контента, используется свойство `MainAxisSize.min`.

---

### 4. Разбор элементов, которые упомянул автор

Автор выделил три ключевых компонента. Давай посмотрим, какие классы Flutter за ними стоят:

1. **"Big solid text" (Converted Price):**
   Это виджет `Text`, но с использованием свойства `style: TextStyle(...)`. Чтобы сделать его «bolded» и большим, мы будем менять `fontWeight` и `fontSize`.
2. **"Simple text field" (User Input):**
   Это виджет `TextField`. Это один из самых сложных виджетов «под капотом», так как он должен открывать клавиатуру, слушать нажатия клавиш и управлять курсором.
3. **"Button" (Convert):**
   Скорее всего, мы будем использовать `ElevatedButton` или `TextButton`. В Material Design 3 (актуальная версия) кнопки имеют встроенные тени и эффекты нажатия.

---

### 5. От себя: Как это будет выглядеть в дереве виджетов

Когда мы начнем писать код, наше дерево (Widget Tree) станет гораздо интереснее. Оно перестанет быть линейным и начнет «ветвиться» внутри `Column`.

---

### Пример кода: "Скелет" того, о чем говорит автор

Вот как инженерно выглядит описание того, что предложил автор:

```dart
Scaffold(
  body: Center(
    child: Column(
      // mainAxisAlignment: MainAxisAlignment.center, // Если захотим по центру экрана
      children: [
        // 1. Текст с ответом
        const Text(
          '0 USD',
          style: TextStyle(
            fontSize: 45,
            fontWeight: FontWeight.bold,
            color: Colors.white,
          ),
        ),
        // 2. Поле ввода
        const TextField(
          decoration: InputDecoration(
            hintText: 'Please enter the amount in INR',
          ),
        ),
        // 3. Кнопка
        ElevatedButton(
          onPressed: () {
            // Тут будет логика конвертации
          },
          child: const Text('Convert'),
        ),
      ],
    ),
  ),
);

```

### На что обратить внимание:

Заметил параметр `children: [...]`? Это массив (List). В отличие от `child`, сюда можно передать бесконечно много виджетов. Но помни: если их станет слишком много и они не поместятся на экран по высоте, Flutter выдаст ошибку «Overflow» (желто-черные полоски). Для исправления этого в будущем мы будем использовать прокрутку (Scroll).
