Этот урок — момент истины для любого Flutter-разработчика. Ты только что увидел классическую проблему: **код логически верен, но интерфейс «мёртв»**.

Давай разберем по косточкам, что происходит в памяти устройства и в движке Flutter, когда ты нажимаешь кнопку «Convert».

---

### 1. Почему `StatelessWidget` кричит об ошибке (Immutability)

Автор попытался создать переменную `result` внутри класса. Flutter сразу выдал ошибку: _"This class is marked as immutable"_.

**Под капотом:**
Виджеты во Flutter — это не долгоживущие объекты. Это временные конфигурации.
Когда ты помечаешь класс как `immutable` (что делает `StatelessWidget`), ты обещаешь компилятору: «После того как этот объект создан, ни один его бит не изменится».

- **Final** — это гарантия.
- **Обычная переменная** — это нарушение обещания.

**Почему это важно?** Flutter пересоздает деревья виджетов тысячи раз. Если бы виджеты были мутабельными (изменяемыми), возник бы хаос: старая версия виджета могла бы иметь одно значение, а новая — другое, и движок бы не понимал, что рисовать.

---

### 2. `TextEditingController`: Твой шпион в текстовом поле

Это важнейший инструмент. Текстовое поле — это отдельный сложный мир.
**Как это работает:**
Контроллер — это объект, который живет **отдельно** от виджета `TextField`. Когда ты печатаешь, `TextField` уведомляет контроллер: «Эй, текст изменился!».
Когда ты нажимаешь кнопку, ты не спрашиваешь `TextField` напрямую. Ты спрашиваешь контроллер: `controller.text`.

**Важное замечание автора:** Контроллер нельзя помечать `const`.
Почему? Потому что внутри контроллера есть список слушателей и текущее состояние текста, которое будет меняться. Константа — это то, что заморожено навсегда. Контроллер же — это динамический объект.

---

### 3. Проблема типов: String vs Double

Автор показал забавный баг: `2.5 * 81 = 2.52.52.5...` (81 раз).
В Dart оператор `*` для строк перегружен так, что он просто дублирует строку.

**Инженерный разбор парсинга:**

- `int.parse()` — упадет с ошибкой, если в поле введено `1.5`.
- `double.parse()` — универсален для нашего случая.

**Трюк для профи:** Чтобы приложение не упало, если пользователь ввел буквы (или оставил поле пустым), вместо `double.parse()` лучше использовать `double.tryParse()`. Он вернет `null` вместо ошибки, если парсинг не удался.

---

### 4. Почему ручной вызов `build()` — это путь в никуда?

Автор попытался вызвать `build(context)` вручную. Это «запрещенный прием».

**Почему это не сработало:**
Даже если ты вызываешь функцию `build` снова:

1. Она начинает выполняться с самого верха.
2. Встречает строку `double result = 0;`.
3. Твой старый результат (например, 202.5) **затирается новым нулем**.

Ты попал в замкнутый круг: чтобы увидеть результат, нужно перерисовать экран, но перерисовка экрана сбрасывает результат.

---

### 5. Понятие "State" (Состояние)

То, что автор пытался сделать (сохранить `result` и `controller`), называется **State**.
**State** — это данные, которые:

1. Могут меняться во время работы приложения.
2. **Должны сохраняться** при перерисовке интерфейса.

---

### Мой профессиональный совет: как это исправить?

Автор подвел тебя к тому, что `StatelessWidget` здесь бессилен. Нам нужен **StatefulWidget**.

**Что произойдет «под капотом» при переходе на StatefulWidget:**

1. У тебя будет два класса вместо одного.
2. Один класс (Widget) останется неизменяемым (immutable).
3. Второй класс (**State**) будет жить долго. Он не будет пересоздаваться при каждом «взмахе ресниц» Flutter.
4. Именно в классе **State** мы объявим `result` и `controller`. Они будут существовать там, пока экран открыт.
