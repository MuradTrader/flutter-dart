Этот урок затрагивает критически важную тему для любого профессионала: **производительность (Performance)** и **жизненный цикл кадра (Frame Lifecycle)**.

Давай разберем, что происходит «под капотом» твоего телефона, когда работает Flutter-приложение.

---

### 1. Почему `build` вызывается так часто? (60/120 FPS)

Автор говорит о 120Hz (Герцах). Это значит, что экран телефона обновляется **120 раз в секунду**. Чтобы пользователь видел плавную анимацию, Flutter должен успеть подготовить новый «чертеж» (виджет) каждые **8.33 миллисекунды** (для 120 Гц) или **16.6 миллисекунд** (для 60 Гц).

**Что происходит под капотом:**
Каждый раз, когда ты вызываешь `setState()`, ты помечаешь текущий элемент как "dirty" (грязный). В следующем кадре движок Flutter видит это и говорит: «О, этот виджет изменился, мне нужно вызвать его метод `build`, чтобы узнать, что рисовать».

Если внутри `build` у тебя будет тяжелый код, который выполняется, например, 15 миллисекунд, а экран требует обновления каждые 8 мс, то Flutter **пропустит кадр**. Пользователь увидит это как микровзрыв или «лаг» (stuttering).

---

### 2. Почему нельзя использовать `async` в `build`?

Это строгое табу. Метод `build` по определению должен быть **синхронным** и возвращать виджет **немедленно**.

**Инженерное объяснение:**
Если ты сделаешь `build` асинхронным (хотя Flutter тебе этого просто не позволит сделать технически), то система не будет ждать завершения твоего `await`. Она просто пойдет дальше, а на экране в этот момент будет пустота или старый кадр. Асинхронные задачи (запросы в интернет, чтение файлов) должны жить в `initState` или специальных методах, а в `build` мы лишь отображаем их результат.

**Пример (Как делать НЕЛЬЗЯ):**

```dart
@override
Widget build(BuildContext context) {
  // НИКОГДА НЕ ДЕЛАЙ ТАК:
  // var data = await getDataFromInternet(); // ОШИБКА: build не может быть async

  return Text("Data");
}

```

---

### 3. "Expense" (Цена) операций

Автор говорит, что создание контроллера или переменной — это дешево, но лучше их выносить.

- **Дешево:** Создание простых объектов, легкие математические расчеты (как твой `result * 81`).
- **Дорого:** Сложные циклы (например, сортировка списка из 10 000 элементов), парсинг огромных JSON-файлов, тяжелые манипуляции с изображениями.

**Пример оптимизации из урока:**
Автор выносит `TextEditingController` из `build` в тело класса `State`.

**Почему это важно под капотом?**
Если контроллер останется в `build`, то при каждом вводе символа (который вызывает перерисовку) будет создаваться **абсолютно новый** объект контроллера. Это не только тратит память, но и заставляет текстовое поле «забывать», на чем оно остановилось.

```dart
class _MyPageState extends State<MyPage> {
  // Создается ОДИН раз при создании State
  final controller = TextEditingController();

  @override
  Widget build(BuildContext context) {
    // build просто использует уже готовый объект
    return TextField(controller: controller);
  }
}

```

---

### 4. Понятие "Frame Drop" (Пропуск кадра)

Когда `build` не укладывается в отведенные 8-16 мс, происходит **Jank** (рывок).

**От себя (совет профи):**
В будущем ты узнаешь про инструмент **Flutter DevTools**. Там есть вкладка "Performance", которая показывает столбцы для каждого кадра. Если столбик красный — значит, твой `build` (или другой этап) был слишком «дорогим» и ты украл плавность у пользователя.

---

### 5. Локальные переменные в `build`

Автор говорит: _"You're just assigning a variable which does hardly anything"_ (Ты просто присваиваешь значение переменной, это почти ничего не стоит).

Это правда. Когда ты пишешь внутри `build`:

```dart
double displayResult = result;

```

Это занимает наносекунды. Это не замедлит приложение. Но хороший тон — держать в `build` только то, что непосредственно описывает UI. Все расчеты лучше проводить в функциях (как функция `convert`), а в `build` просто отображать готовую переменную `result`.

### Резюме:

1. **build** — это конвейер. Он должен лететь со скоростью пули.
2. Любая задержка в **build** = плохой отзыв в App Store за «тормоза».
3. Тяжелые объекты и логику выносим в класс **State**, чтобы они жили там долго и не пересоздавались каждую миллисекунду.
