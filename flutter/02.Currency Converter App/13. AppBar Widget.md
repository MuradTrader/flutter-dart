Этот урок завершает визуальное проектирование и плавно переводит тебя к самому «сердцу» разработки — **бизнес-логике**. Автор затронул важные моменты: как сделать `AppBar` невидимым, но полезным, и как спланировать работу приложения.

Как твой партнер-разработчик, я разберу устройство `AppBar` и то, почему предложенный план действий в `StatelessWidget` — это «ловушка», в которую попадают все новички.

---

### 1. Архитектура `AppBar`: Прозрачность и Тени

Автор решил сделать `AppBar` того же цвета, что и фон, и убрал `elevation`.

**Под капотом:**
Когда ты устанавливаешь `elevation: 0`, ты отключаешь отрисовку слоя тени (`PhysicalModel`). В Material Design `AppBar` по умолчанию имеет небольшое возвышение, чтобы отделять контент от заголовка. Делая его «плоским», ты создаешь современный минималистичный дизайн.

**Пример кода:**

```dart
appBar: AppBar(
  backgroundColor: Colors.blueGrey, // Сливается с фоном Scaffold
  elevation: 0,                   // Убираем линию раздела
  title: const Text('Currency Converter'),
  centerTitle: true,             // Принудительно центрируем для всех платформ
)

```

---

### 2. Leading и Actions: Анатомия заголовка

Автор упомянул `leading` и `actions`. Это ключевые точки интерактивности.

- **Leading (Слева):** Обычно здесь находится кнопка «Назад» или «Гамбургер-меню». В 90% случаев это `IconButton`.
- **Actions (Справа):** Это список (`List<Widget>`). В коде они упакованы в `Row`. Поскольку это список, иконки будут выстраиваться друг за другом.

**Инженерный нюанс:** Если ты не укажешь `leading`, но используешь `Drawer` (боковое меню), Flutter **автоматически** вставит туда иконку меню. Это называется "implying leading".

---

### 3. План логики: Где прячется подвох?

Автор предложил 4 логичных шага:

1. Создать переменную для результата (например, `double result = 0;`).
2. Создать функцию для умножения.
3. Сохранить результат в переменную.
4. Вывести её на экран.

**Почему это НЕ сработает в `StatelessWidget`?**
Это самый важный момент во всем курсе.
`StatelessWidget` — это **неизменяемый** объект. Когда ты нажимаешь кнопку «Convert», ты можешь изменить значение переменной в памяти телефона, но **экран не перерисуется**.

Во Flutter экран обновляется только тогда, когда виджет «понимает», что его состояние изменилось. `StatelessWidget` по определению не умеет следить за изменениями своих данных после того, как он был отрисован.

---

### 4. Под капотом: Как мы будем получать данные из `TextField`?

Чтобы реализовать план автора, нам понадобится **`TextEditingController`**.
Это объект, который «слушает» текстовое поле. Без него мы не сможем узнать, что именно пользователь напечатал в поле, когда нажата кнопка.

**От себя (профессиональный совет):**
Никогда не делай расчеты прямо в методе `onPressed`. Выноси их в отдельную функцию или (в будущем) в отдельный класс (Бизнес-логику). Это делает код тестируемым.

---

### 5. Пример того, как должен выглядеть "мозг" функции (подготовка):

Автор предложил умножать на 81. В коде это будет выглядеть примерно так:

```dart
// Это будет внутри нашего будущего Stateful класса
double result = 0;
final TextEditingController textEditingController = TextEditingController();

void convert() {
  // 1. Получаем строку из контроллера
  // 2. Парсим её в число (double.parse)
  // 3. Умножаем и обновляем результат
  result = double.parse(textEditingController.text) * 81;

  // НО! Чтобы текст на экране изменился, нам понадобится магическая функция
  // setState(() {}); о которой ты скоро узнаешь.
}

```

### Итог:

Мы закончили с «лицом» приложения. Оно красивое, кнопки нажимаются, но они ничего не делают.
Следующий шаг — **переход от `StatelessWidget` к `StatefulWidget**`. Это момент, когда ты перестанешь просто «рисовать» и начнешь по-настоящему «программировать» поведение.
