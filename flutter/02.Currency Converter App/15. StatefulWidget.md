Этот урок — один из самых важных во всем курсе. Ты только что перешел от «рисования» интерфейса к созданию «живого» приложения. Как Senior Flutter разработчик, я разберу для тебя архитектуру `StatefulWidget` так, чтобы ты понимал не только _как_ писать, но и _почему_ это устроено именно так.

---

### 1. Почему два класса? (Архитектура StatefulWidget)

Тебя могло удивить, почему для одного экрана нам нужно целых два класса.

**Под капотом:**
Во Flutter виджеты должны быть **неизменяемыми (Immutable)**. Когда экран нужно обновить, старый виджет просто выбрасывается и создается новый.

1. **Класс Widget (`StatefulWidget`)**: Это временная «коробка». Она создается и уничтожается очень быстро. Она хранит только неизменяемые параметры (например, ключ `Key`).
2. **Класс State**: Это «долгожитель». Он создается один раз и живет в памяти всё то время, пока пользователь видит этот экран. Именно поэтому мы можем хранить там `result` и `controller` — они не сбросятся в ноль при перерисовке.

---

### 2. Зачем нужна магия с Generic (`State<T>`)?

Автор упомянул передачу типа в угловых скобках: `extends State<CurrencyConverterMaterialPage>`.

**Инженерное объяснение:**
Это позволяет классу `State` точно знать, к какому виджету он привязан. Благодаря этому внутри класса `State` тебе доступно специальное свойство `widget`. Через него ты можешь достучаться до параметров, которые лежат в первом классе.

**Пример кода:**

```dart
class MyPage extends StatefulWidget {
  final String title = "Конвертер"; // Данные в виджете
  @override
  State<MyPage> createState() => _MyPageState();
}

class _MyPageState extends State<MyPage> {
  @override
  Widget build(BuildContext context) {
    // Мы обращаемся к данным виджета через свойство 'widget'
    return Text(widget.title);
  }
}

```

---

### 3. Жизненный цикл (Lifecycle) и `initState`

Это критически важная концепция. В `StatelessWidget` у тебя был только `build`, а здесь появляется целая цепочка событий.

**Порядок вызова под капотом:**

1. **Constructor**: Создается объект виджета.
2. **createState()**: Виджет создает свой долгоживущий `State`.
3. **initState()**: Вызывается **ровно один раз** в жизни экрана. Это идеальное место для инициализации контроллеров, подключения к базе данных или подписки на события.
4. **didChangeDependencies()**: (пройдешь позже) подготовка данных.
5. **build()**: Отрисовка интерфейса. Может вызываться сотни раз.

---

### 4. Почему контроллеры нужно выносить из `build`?

Автор сказал: _"build function should always be as less expensive as it can be"_ (функция build должна быть как можно менее «дорогой»).

**Профессиональный взгляд:**
Если ты создаешь `TextEditingController` внутри `build`, то при каждой перерисовке (например, когда пользователь вводит символ) будет создаваться **новый экземпляр** контроллера.

- Это приведет к потере фокуса (клавиатура может закрываться).
- Это создаст лишнюю нагрузку на мусорщик (Garbage Collector).

**Правильный подход:**
Объявляй контроллеры как поля класса `State`. Они создадутся один раз и будут существовать, пока живет экран.

---

### 5. От себя: Про Dispose

Автор упомянул метод `dispose`, но пока не заострил на нем внимание. Как профи, добавлю: **всегда удаляй контроллеры!**
Когда пользователь уходит с этого экрана, `State` уничтожается. Но `TextEditingController` — это объект, который «слушает» систему. Если его не закрыть в `dispose`, он останется в памяти и будет вызывать «утечку памяти» (memory leak).

**Пример кода (обязательный стандарт):**

```dart
@override
void dispose() {
  textEditingController.dispose(); // Освобождаем ресурсы
  super.dispose();
}

```

---

### Итог урока:

Теперь у тебя есть место (класс `State`), где данные не пропадают. Ты узнал, что `initState` — это подготовка перед боем, а `build` — это сама битва за пиксели.

Это отличный вопрос. На первый взгляд это кажется избыточным: «Зачем мне два класса, если я просто хочу поменять текст на экране?». Но за этим стоит фундаментальная архитектура Flutter, которая делает его таким быстрым.

Давай разберем это на примере **«Чертежа»** и **«Реального объекта»**.

---

### 1. Почему Виджет должен быть неизменяемым (Immutable)?

Во Flutter виджеты — это просто **инструкции** или «чертежи». Flutter пересоздает их постоянно (до 60 или 120 раз в секунду). Если бы виджеты были тяжелыми и изменяемыми, приложение бы жутко тормозило.

Поэтому первый класс `MyPage` (наследник `StatefulWidget`) — это **неизменяемый чертеж**. Он очень легкий. Его можно выбрасывать и создавать заново без потери производительности.

### 2. Зачем нужен второй класс (`State`)?

Представь, что ты строишь дом. Чертеж может меняться, но нам нужно место, где мы будем хранить **реальные вещи**, которые сейчас находятся в доме (например, сколько воды в баке).

Класс `_MyPageState` — это и есть тот самый «бак с водой» или **состояние**.

- Он **не удаляется**, когда Flutter перерисовывает экран.
- Он хранит данные (переменные, контроллеры) в памяти долго.

---

### 3. Как они работают в паре (Под капотом)

Когда ты запускаешь приложение, происходит следующее:

1. **Создание виджета:** Flutter создает объект `MyPage`.
2. **Создание состояния:** Flutter видит, что это `StatefulWidget`, и вызывает `createState()`. В памяти создается объект `_MyPageState`.
3. **Связка:** Flutter «склеивает» их вместе. Теперь у `_MyPageState` появляется свойство `widget`, которое указывает на текущий чертеж (`MyPage`).
4. **Отрисовка:** Вызывается метод `build` внутри `State`, и мы видим экран.

**А теперь самое главное — что происходит при обновлении?**
Когда данные меняются (например, курс валюты), Flutter создает **новый** объект `MyPage` (новый чертеж), но **старый** объект `_MyPageState` остается в памяти! Flutter просто обновляет ссылку `widget` в состоянии, чтобы она указывала на новый чертеж.

---

### 4. Наглядный пример (В контексте урока)

Представь, что у нас есть переменная `double result`.

```dart
// КЛАСС 1: Чертеж (Виджет)
// Он говорит: "Я — страница конвертера, и у меня есть цвет фона"
class CurrencyConverter extends StatefulWidget {
  final Color backgroundColor = Colors.blueGrey; // Это не изменится

  @override
  _CurrencyConverterState createState() => _CurrencyConverterState();
}

// КЛАСС 2: Память (Состояние)
// Он говорит: "Я помню, сколько накликал пользователь"
class _CurrencyConverterState extends State<CurrencyConverter> {
  double result = 0; // Эта переменная ЖИВЕТ здесь долго

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      // Обращаемся к КЛАССУ 1 через widget.backgroundColor
      backgroundColor: widget.backgroundColor,
      body: Text("Результат: $result"), // Используем переменную из КЛАССА 2
    );
  }
}

```

### Резюме:

- **`StatefulWidget`** — это «внешность», которая может быть легко заменена. Он **Immutable** (неизменяемый).
- **`State`** — это «мозг и память», которые живут долго. Он **Mutable** (изменяемый).

Если бы всё было в одном классе, Flutter пришлось бы хранить все тяжелые данные прямо в чертежах, и при каждой перерисовке (а их тысячи!) он бы тратил кучу ресурсов на их копирование. Разделение на два класса позволяет Flutter быть невероятно быстрым: он меняет только дешевые чертежи, оставляя логику в стабильном состоянии.

Это отличный вопрос, который бьет прямо в цель! Короткий ответ: **Flutter показывает пользователю результат работы метода `build`, который находится внутри `_CurrencyConverterState`.**

Но чтобы ты стал профи, давай разберем это на уровне «движка» Flutter. Есть три дерева, которые работают одновременно, и именно в них кроется ответ.

---

### 1. Трехуровневая система (Секрет Flutter)

Когда ты запускаешь приложение, Flutter создает не одно дерево, а три:

1. **Дерево Виджетов (Widget Tree):** Это твои `CurrencyConverter` и `Scaffold`. Это просто «чертежи». Пользователь их не видит.
2. **Дерево Элементов (Element Tree):** Это «менеджеры». Вот тут и живет твой `_CurrencyConverterState`. Элемент связывает чертеж с тем, что будет на экране.
3. **Дерево Рендера (Render Tree):** Это реальные объекты (пиксели). Именно их видит пользователь.

---

### 2. Кто за что отвечает?

Посмотри на это как на театральную постановку:

- **`CurrencyConverter` (Widget)** — это **Сценарий**. В нем написано: «На сцене должен быть синий фон и текст». Сценарий можно переписывать или менять на новый хоть каждую секунду.
- **`_CurrencyConverterState` (State)** — это **Актер**. Он выходит на сцену и «живет» там. Он помнит свою роль и сколько раз он прыгнул (переменная `result`).
- **То, что видит пользователь** — это **Спектакль**. Это то, что Актер (State) «играет» на основе Сценария (Widget).

Когда ты нажимаешь кнопку, ты меняешь данные в **Актере (State)**. Он говорит системе: «Я изменился, дайте мне новый **Сценарий (Widget)**, я переиграю эту сцену!».

---

### 3. Наглядная цепочка событий

Давай проследим путь от кода до глаза пользователя:

1. Flutter вызывает `CurrencyConverter()`.
2. Создается «Элемент» (Менеджер), который вызывает `createState()`.
3. Создается объект `_CurrencyConverterState`.
4. Flutter говорит этому объекту: **«Эй, State, выполни свой метод `build`, покажи, что мне рисовать?»**.
5. `_CurrencyConverterState` берет данные из себя (`result`) и данные из виджета (`widget.backgroundColor`) и выдает дерево виджетов (Scaffold, Text и т.д.).
6. Flutter превращает этот результат в **RenderObjects** — конкретные инструкции для видеокарты (нарисуй квадрат здесь, напиши текст там).

**В итоге:** Пользователь видит пиксели, которые сгенерировал метод `build` твоего **State**.

---

### Почему это сделано именно так? (Взгляд Senior разработчика)

Если бы пользователь «видел» напрямую `CurrencyConverter`, то каждый раз, когда нам нужно поменять цифру, нам пришлось бы уничтожать всё окно и создавать его заново. Это очень дорого для процессора.

Разделение позволяет Flutter делать **«хитрый трюк»**:
Когда `result` меняется, Flutter выбрасывает старый легкий чертеж `CurrencyConverter`, создает новый, но **Актер (`State`) остается на месте**. Он просто подхватывает новый чертеж и обновляет только ту маленькую часть экрана, где изменилась цифра. Это и делает Flutter таким быстрым (60-120 FPS).

---

**Пример в коде:**

```dart
// Этот класс Flutter может пересоздавать 100 раз в минуту.
class CurrencyConverter extends StatefulWidget {
  final double rate = 81.0;
  @override
  _CurrencyConverterState createState() => _CurrencyConverterState();
}

// Этот класс создастся ОДИН раз и будет "жить", пока страница открыта.
class _CurrencyConverterState extends State<CurrencyConverter> {
  double result = 0; // Состояние живет здесь

  @override
  Widget build(BuildContext context) {
    // Пользователь видит то, что возвращается ОТСЮДА
    return Text("${result * widget.rate}");
  }
}

```

Твоё замешательство абсолютно понятно — это самый сложный момент в понимании Flutter. Давай разберем «магию» того, как **неизменный объект (State)** заставляет экран **меняться**.

Секрет в том, что хотя сам объект `_CurrencyConverterState` не удаляется, он **заново запускает свой метод `build**`.

### 1. Как это работает «под капотом» (Пошагово)

Представь, что объект `State` — это **художник**, а метод `build` — это **процесс рисования картины**.

1. **Начало:** Художник (`State`) один раз берет чистый холст и рисует цифру `0`. Пользователь видит результат.
2. **Действие:** Ты вводишь число и нажимаешь кнопку «Convert».
3. **Изменение данных:** Внутри Художника переменная `result` меняется с `0` на `100`. Но холст перед глазами пользователя всё ещё старый (там нарисован `0`).
4. **Команда `setState()`:** Это самый важный момент. Когда ты вызываешь `setState()`, ты как бы хлопаешь Художника по плечу и говоришь: **«Твои данные изменились, перерисуй картину!»**.
5. **Перерисовка:** Художник (`State`) **не умирает**, он просто **снова выполняет функцию `build**`. Он смотрит на свою переменную (теперь там `100`) и выдает Flutter-у новый чертеж.
6. **Обновление пикселей:** Flutter сравнивает старый чертеж и новый, видит разницу и перекрашивает на экране только те пиксели, где была цифра.

### 2. Почему это эффективно?

Если бы мы пересоздавали сам объект `State`, мы бы теряли всё, что в нём было (текст в полях, положение прокрутки и т.д.). А так:

- **Память (данные)** — сохраняется (потому что `State` живет долго).
- **Картинка (интерфейс)** — обновляется (потому что `build` вызывается заново).

---

### 3. Пример в коде (из твоего урока)

Давай посмотрим, что происходит в коде, когда ты нажимаешь кнопку:

```dart
class _CurrencyConverterState extends State<CurrencyConverter> {
  double result = 0; // Эта переменная в памяти живет долго

  void convert() {
    // 1. Мы вызываем setState
    setState(() {
      // 2. Внутри этой функции мы меняем данные
      result = 81.0;
    });
    // 3. СРАЗУ ПОСЛЕ ЭТОГО Flutter автоматически вызывает метод build!
  }

  @override
  Widget build(BuildContext context) {
    // 4. Метод build запускается снова, видит, что result теперь 81.0
    // и возвращает Text("81.0") вместо Text("0")
    return Text(result.toString());
  }
}

```

### 4. Важный нюанс: Три Дерева

Чтобы ты понимал это как профессионал, запомни:
Пользователь видит **не код**, пользователь видит **Render Tree** (дерево отрисовки).

- `State` (Актер) — стоит за кулисами.
- `build` — это его выступление.
- **Когда актер меняет состояние**, он просто выходит и выступает заново. Его не нужно увольнять и нанимать нового актера (`State`), чтобы спектакль на сцене изменился.

### Резюме:

Пользователь видит меняющееся состояние, потому что **объект `State` умеет «переподавать» информацию**. Он говорит Flutter-у: «Я всё тот же, но мой взгляд на то, как должен выглядеть экран, изменился. Вот тебе новый чертеж (Widget), отрисуй его».

**Теперь логика «живого» состояния и «перерисовываемого» чертежа стала понятнее?** Если нет — спрашивай, мы будем копать, пока ты не почувствуешь себя уверенно!
