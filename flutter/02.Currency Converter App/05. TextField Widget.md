Этот этап — один из сложнейших в дизайне интерфейсов на Flutter. Ты только что разобрал, как работает **TextField**, и это не просто «поле для ввода», а целая экосистема параметров.

Давай разберем, что происходит «под капотом», когда ты создаешь и стилизуешь текстовое поле, как профессиональный разработчик.

---

### 1. Почему `InputDecoration` такая сложная?

Автор подметил: чтобы настроить поле, нужно залезть в `decoration`.
**Инженерное объяснение:**
`TextField` — это виджет, который отвечает за **логику** (обработка нажатий, фокус, вызов клавиатуры). А вот за то, как он **выглядит** (рамки, иконки, подсказки), отвечает специальный класс `InputDecorator`.
Flutter разделяет логику ввода и визуальное представление. Это позволяет тебе менять «скины» поля, не затрагивая то, как оно работает с текстом.

---

### 2. Разница между Label, Hint и Helper

Автор экспериментировал с типами текста. Вот как это работает в иерархии Flutter:

- **Hint Text:** Самый простой. Исчезает, как только ты начинаешь печатать. Он не занимает места в макете, когда поле пустое.
- **Label Text:** Это «умный» текст. В Material Design он «всплывает» наверх, когда ты нажимаешь на поле. Это удобно, чтобы пользователь не забыл, что он вводит, даже когда поле уже заполнено.
- **Helper Text:** Находится **под** полем. Он всегда виден и нужен для инструкций (например, «Пароль должен быть длиннее 8 символов»).

---

### 3. Иконки: Prefix vs Suffix

Автор затронул тему `prefixIcon` и `Icons`.
**Под капотом:**
Виджет `Icon` — это просто отрисовка конкретного символа из шрифта (обычно это шрифт **Material Icons**). Каждая иконка имеет свой `codePoint` (например, `0xe123`).
Класс `Icons.monetization_on` — это просто удобный способ для нас получить этот код, не запоминая цифры.

- **Prefix Icon:** Рисуется **внутри** контейнера поля ввода слева.
- **Prefix Text:** Рисуется как часть текста, но его нельзя стереть (например, символ `$` перед цифрами).

---

### 4. Состояния границ (Borders)

Это самый важный момент для понимания. Поле ввода во Flutter имеет несколько состояний, и для каждого — своя граница:

1. **enabledBorder:** Поле доступно для ввода, но ты на него еще не нажал.
2. **focusedBorder:** Ты нажал на поле, появился курсор (оно в фокусе).
3. **disabledBorder:** Поле заблокировано.
4. **errorBorder:** Если сработала валидация и данные введены неверно.

Автор очень правильно сделал: он вынес настройки границы в отдельную переменную `final border`.
**Почему это профессионально?** Если ты хочешь изменить толщину рамки, тебе не нужно менять её в пяти местах. Ты меняешь её в переменной `border`, и она обновляется везде. Это принцип **DRY** (Don't Repeat Yourself — не повторяйся).

---

### 5. Понимание `const` и динамических объектов

Автор столкнулся с ошибкой `const`. Это критически важный момент.
**Инженерное объяснение:**
`const` во Flutter означает, что объект создается **на этапе компиляции**, а не во время работы программы.

- `BorderRadius.circular(60)` — это не константа, потому что внутри него происходит математическое вычисление радиуса.
- Как только ты добавляешь в дерево виджетов что-то «непостоянное» (переменную или не-const объект), всё родительское дерево выше не может быть `const`.

**Совет профи:** Всегда старайся использовать `const` там, где это возможно. Это экономит оперативную память телефона, так как Flutter не пересоздает эти объекты при каждом обновлении экрана (ребилде).

---

### 6. От себя: Параметры клавиатуры

Автор настраивает внешний вид, но для приложения-конвертера валют крайне важно настроить и **поведение**.
Если ты оставишь `TextField` как есть, у пользователя откроется обычная клавиатура с буквами. Для конвертера это плохой UX (пользовательский опыт).

**Что стоит добавить профессионалу:**

```dart
TextField(
  keyboardType: TextInputType.numberWithOptions(decimal: true), // Только цифры и точка
  style: const TextStyle(color: Colors.black),
  decoration: InputDecoration(
    // ... твои декорации
  ),
)

```

### Резюме по коду:

Автор создал переменную `border` внутри метода `build`. Это хорошее решение для начала. В будущем ты сможешь вынести такие настройки в **ThemeData**, чтобы все текстовые поля в приложении выглядели одинаково автоматически.

Продолжим разбор твоего последнего фрагмента, где автор оптимизировал код, вынося границы в переменные.

---

### 1. Переменные в методе `build`: Оптимизация и DRY

Автор вынес `OutlineInputBorder` в переменную `border`. С точки зрения архитектуры — это переход от «кодинга на коленке» к чистому коду.

**Под капотом:**
Когда ты создаешь переменную внутри `build`, она пересоздается при каждом обновлении экрана (ребилде). Однако это всё равно лучше, чем дублировать огромные куски кода в разных свойствах (`enabledBorder`, `focusedBorder`), так как это упрощает чтение кода компилятором и тобой.

**Пример кода:**

```dart
@override
Widget build(BuildContext context) {
  // Выносим стиль границы, чтобы не дублировать код
  final customBorder = OutlineInputBorder(
    borderSide: const BorderSide(
      color: Colors.black,
      width: 2.0,
    ),
    borderRadius: BorderRadius.circular(10),
  );

  return TextField(
    decoration: InputDecoration(
      enabledBorder: customBorder, // Используем переменную
      focusedBorder: customBorder, // И здесь тоже
      hintText: 'Введите сумму',
    ),
  );
}

```

---

### 2. Разница между `EnabledBorder` и `FocusedBorder`

Автор заметил, что при нажатии на поле оно «прыгало» или меняло цвет. Это стандартное поведение Material Design.

- **EnabledBorder:** Как выглядит поле, когда оно просто лежит на экране.
- **FocusedBorder:** Как оно выглядит, когда пользователь нажал на него и готов вводить текст.

**Зачем их делать одинаковыми?** В минималистичных дизайнах (как в приложении-конвертере) часто хотят избежать лишних визуальных изменений, чтобы интерфейс выглядел стабильно.

**Пример кода:**

```dart
decoration: InputDecoration(
  // Серая граница в обычном состоянии
  enabledBorder: OutlineInputBorder(
    borderSide: BorderSide(color: Colors.grey),
  ),
  // Синяя и толстая граница, когда мы нажали на поле
  focusedBorder: OutlineInputBorder(
    borderSide: BorderSide(color: Colors.blue, width: 3),
  ),
),

```

---

### 3. Обработка `const` при динамических радиусах

Ты видел, как автор убирал `const` у `Scaffold`. Это происходит потому, что `BorderRadius.circular(60)` — это функция, результат которой вычисляется во время работы программы (runtime), а не компиляции.

**Профессиональный совет:** Если ты хочешь вернуть `const`, тебе нужно использовать константные конструкторы, если они доступны, но для радиусов чаще всего приходится просто смириться с отсутствием `const` на верхнем уровне.

**Пример кода (как ломается const):**

```dart
// ОШИБКА: нельзя использовать const, если внутри есть вызов функции
// const Scaffold(body: TextField(...BorderRadius.circular(10)...))

// ПРАВИЛЬНО: убираем const у родителя, но оставляем у вложенных данных, где можно
Scaffold(
  body: TextField(
    style: const TextStyle(color: Colors.white), // Здесь можно const
    decoration: InputDecoration(
      border: OutlineInputBorder(
        borderRadius: BorderRadius.circular(10), // Здесь нельзя
      ),
    ),
  ),
);

```

---

### 4. Под капотом: `UnderlineInputBorder` vs `OutlineInputBorder`

Автор показал, что `Underline` рисует только линию снизу.

- **UnderlineInputBorder:** Использует метод `canvas.drawLine` (рисует одну линию по нижней границе).
- **OutlineInputBorder:** Использует метод `canvas.drawRRect` (рисует прямоугольник с закругленными углами).

**Пример кода (сравнение):**

```dart
// Поле как в классических формах Google (просто черта)
decoration: InputDecoration(
  border: UnderlineInputBorder(),
),

// Поле в виде карточки/блока (рамка вокруг)
decoration: InputDecoration(
  border: OutlineInputBorder(),
),

```
