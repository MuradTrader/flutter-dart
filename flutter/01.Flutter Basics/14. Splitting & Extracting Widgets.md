Этот этап — переход от «песочницы» к **структуре реального проекта**. Автор затронул темы архитектуры, чистоты кода и того, как Flutter управляет файлами. Давай разберем это с точки зрения профессионального инженера.

---

### 1. Архитектурное разделение: MaterialApp vs Page

Автор говорит, что `MaterialApp` может быть сильно перегружен. Это правда.

**Под капотом:**
`MaterialApp` — это конфигуратор всей системы. Если ты запихнешь в него весь UI (Scaffold и прочее), то каждый раз, когда тебе нужно будет поменять цвет текста на одной странице, Flutter будет вынужден перепроверять настройки всего приложения (темы, навигацию, локализацию).
Разделяя их, мы создаем **границы ответственности**:

- `main.dart` — это «конфигурационный файл» приложения.
- `currency_converter_material_page.dart` — это конкретный экран.

### 2. Зачем нам `import` в каждом файле?

Автор отметил: _«import lines are specific to the file»_.

**Как это работает в Dart:**
Каждый файл в Dart — это отдельная **библиотека (library)**. Даже если файлы лежат в одной папке, они не видят друг друга и не делят общие импорты.

- Когда ты импортируешь `material.dart`, компилятор Dart подключает определения классов `StatelessWidget`, `Scaffold`, `Center` именно к области видимости этого конкретного файла.
- Это сделано для **производительности компиляции**. Компилятору не нужно перерывать весь проект, чтобы понять, откуда взялся класс `Scaffold` — он просто смотрит в список импортов текущего файла.

### 3. Разбор нейминга: `snake_case` vs `PascalCase`

Автор упомянул: `currency_converter_material_page.dart`.

Во Flutter и Dart есть строгий стандарт (**Effective Dart**):

1. **Названия файлов:** `snake_case` (маленькие буквы, разделение подчеркиванием). Например: `user_profile_screen.dart`.
2. **Названия классов:** `PascalCase` (каждое слово с большой буквы). Например: `CurrencyConverterMaterialPage`.

Это не просто эстетика. Инструменты Flutter (командная строка, IDE) ожидают именно такой формат для автоматической генерации кода в будущем.

### 4. BuildContext: Что это на самом деле?

Автор мельком упомянул `build(BuildContext context)`. Давай заглянем чуть глубже, чем он.

**Профессиональное объяснение:**
`BuildContext` — это, по сути, **указатель на место виджета в дереве**.
Представь дерево виджетов как карту. Когда виджету `Text` нужно узнать, какой сейчас основной цвет приложения, он не лезет в глобальные переменные. Он говорит:

> "Эй, `context`, ты знаешь, где я нахожусь. Сходи вверх по дереву до самого `MaterialApp` и принеси мне настройки темы (`Theme.of(context)`)".

Без этого `context` виджет был бы изолирован и не мог бы взаимодействовать с «миром» вокруг него.

---

### 5. От меня: Почему разделение на файлы ускоряет разработку (Hot Reload)

Когда у тебя весь код в одном файле `main.dart`, при сохранении Flutter приходится анализировать весь этот огромный файл целиком.
Когда ты разносишь код по файлам:

1. **Изоляция изменений:** Ты меняешь код в файле страницы. Flutter понимает, что `main.dart` не изменился, и обновляет только ту ветку дерева, которая описана в измененном файле.
2. **Читаемость:** Профессиональные проекты содержат сотни файлов. Навигация по файлам в боковой панели IDE гораздо быстрее, чем скроллинг файла на 2000 строк.

---

### Практический пример: Как теперь выглядит связь файлов

**Файл 1: `lib/main.dart**`

```dart
import 'package:flutter/material.dart';
// Мы импортируем наш новый файл, чтобы main узнал о существовании этого класса
import 'package:currency_converter/currency_converter_material_page.dart';

void main() {
  runApp(const MyApp());
}

class MyApp extends StatelessWidget {
  const MyApp({super.key});

  @override
  Widget build(BuildContext context) {
    return const MaterialApp(
      // Теперь home просто вызывает наш класс. Чисто и красиво!
      home: CurrencyConverterMaterialPage(),
    );
  }
}

```

**Файл 2: `lib/currency_converter_material_page.dart**`

```dart
import 'package:flutter/material.dart';

class CurrencyConverterMaterialPage extends StatelessWidget {
  const CurrencyConverterMaterialPage({super.key});

  @override
  Widget build(BuildContext context) {
    return const Scaffold(
      body: Center(
        child: Text('Hello from separate file!'),
      ),
    );
  }
}

```

### Маленький секрет от профи:

Автор использовал `const` при вызове `CurrencyConverterMaterialPage()`. Если внутри этого класса все данные известны заранее (нет переменных, которые меняются), использование `const` позволяет Flutter **никогда** не перерисовывать этот экран заново, если в `main.dart` что-то изменится. Это экономит циклы процессора.
